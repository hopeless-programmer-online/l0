throw(message) {
    print(message)

    /super()
}
assert_type(target, expected_type) {
    actual_type : type_of(target)
    is_not : !=(actual_type, expected_type)

    then() {
        throw("type mismatch")
    }

    if (is_not, then)
}
f() {
    assert_type(true, Boolean)
}

; @class
; @param value: something
Immediate_Value(value) {
    object : List()

    ; #0
    push_back(object, "immediate value")
    ; #1
    push_back(object, value)

    super(object)
}

; @class
; @param targets: List(Value)
; @param buffer: List(Value)
Instruction_Value(targets, buffer) {
    object : List()

    ; #0
    push_back(object, "instruction value")
    ; #1
    push_back(object, targets)
    ; #2
    push_back(object, buffer)

    super(object)
}
; @type Value: Or(Immediate_Value, Instruction_Value)

; dummy super
terminator() {}

; restore buffer of internal instruction at the call time
; @param internal: internal instruction
; @param params: List(Value)
restore_buffer(internal, params) {
    buffer : get_buffer(internal) ; original buffer

    push_front(buffer, internal) ; add self at 0

    buffer : map(buffer, Immediate_Value) ; make all values immediates
    buffer : +(buffer, params) ; concat with params

    ; transform buffer according to template
    template : get_template(internal)
    targets : get_targets(template)

    callback(index) {
        value : get(buffer, index)

        super(value)
    }

    next : map(targets, callback)

    super(next)
}

; @param instruction: Value
; @returns List(Value)
extract_targets(instruction) {
    type : get(instruction, 0)

    check_immediate() {
        is_not_immediate : !=(type, "immediate value")

        if (is_not_immediate, super)

        ; print("immmediate")

        ; assumes that immediate value is template
        template : get(instruction, 1)

        print(template)

        targets : get_targets(template)
        targets : map(targets, Immediate_Value)

        /super(targets)
    }

    check_immediate()

    throw("cannot extract targets")
}

; @param buffer: List(Value)
step(buffer) {
    print("step")

    op : get(buffer, 0)

    ; print("op: ", op)

    type : get(op, 0)

    check_immediate() {
        is_not_immediate : !=(type, "immediate value")

        if (is_not_immediate, super)

        print("immediate")

        value : get(op, 1)

        print(value)

        check_internal() {
            is : is_internal(value)
            is : not(is)

            if (is, super)

            print("internal")

            check_throw() {
                is_not_throw : !=(value, throw)

                if (is_not_throw, super)

                print("throw")

                throw("throw reached")
            }
            check_terminator() {
                is_not_terminator : !=(value, terminator)

                if (is_not_terminator, super)

                print("terminator")

                throw("terminator reached")
            }

            check_throw()
            check_terminator()

            params : slice(buffer, 1)
            next : restore_buffer(value, params)

            //super(next)
        }
        check_external() {
            is : is_external(value)
            is : not(is)

            if (is, super)

            print("external")

            check_bind() {
                is_not_bind : !=(value, bind)

                if (is_not_bind, super)

                print("bind")

                ; slice params for next & target
                params : slice(buffer, 3)

                ; create contonuation instruction
                next : get(buffer, 1)
                next : extract_targets(next)
                next : Instruction_Value(next, params)

                ; create target instruction
                target : get(buffer, 2)
                target : extract_targets(target)
                target : Instruction_Value(target, params)

                push_back(params, target)

                ; fill result buffer
                buffer : List()

                push_back(buffer, next) ; next as currect program
                ; push_back(buffer, next) ; next as super (is this even needed?)

                ///super(buffer)
            }
            check_if() {
                is_not_if : !=(value, if)

                if (is_not_if, super)

                print("if")

                next : get(buffer, 1)
                condition : get(buffer, 2)
                then : get(buffer, 3)

                ; print(condition)

                condition_type : get(condition, 0)

                check_immediate_condition() {
                    is_not_immediate : !=(condition_type, "immediate value")

                    if (is_not_immediate, super)

                    print("immediate condition")

                    condition_value : get(condition, 1)

                    then_branch() {
                        buffer : List()

                        push_back(buffer, then, next)

                        /////super(buffer)
                    }

                    if (condition_value, then_branch)

                    buffer : List()

                    push_back(buffer, next, next)

                    ////super(buffer)

                    throw("cannot check over immediate condition")
                }

                check_immediate_condition()

                throw("cannot check over if")
            }
            check_type_of() {
                is_not : !=(value, type_of)

                if (is_not, super)

                print("type_of")

                target : get(buffer, 2)
                target_type : get(target, 0)

                check_immediate_target() {
                    is_not : !=(target_type, "immediate value")
                }

                check_immediate_target()

                throw("cannot check over type_of")
            }

            check_bind()
            check_if()
            check_type_of()

            throw("cannot check over external")
        }

        check_internal()
        check_external()

        throw("cannot check over immediate")
    }
    check_instruction() {
        is_not_instruction : !=(type, "instruction value")

        if (is_not_instruction, super)

        print("instruction")

        targets : get(op, 1)
        storage : get(op, 2)
        params : slice(buffer, 1)

        ; print(params)

        buffer : +(storage, params)
        push_front(buffer, op)

        callback(target) {
            type : get(target, 0)

            check_immediate() {
                is_not_immediate : !=(type, "immediate value")

                if (is_not_immediate, super)

                ; print("immediate")

                value : get(target, 1)
                value : get(buffer, value)

                /super(value)
            }

            check_immediate()

            throw("cannot process target")
        }

        buffer : map(targets, callback)

        /super(buffer)
    }

    check_immediate()
    check_instruction()

    throw("cannot step")
}

params : List()

; add terminator as super
push_back(params, terminator)

params : map(params, Immediate_Value)
buffer : restore_buffer(f, params)

loop(buffer) {
    buffer : step(buffer)
    loop(buffer)
}

loop(buffer)
