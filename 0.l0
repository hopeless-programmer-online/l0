throw(message) {
    print(message)

    /super()
}
f() {
    throw()
}

; @class
; @param value: something
Immediate_Value(value) {
    object : List()

    ; #0
    push_back(object, "immediate value")
    ; #1
    push_back(object, value)

    super(object)
}

; @class
; @param targets: List(Value)
; @param buffer: List(Value)
Instruction_Value(targets, buffer) {
    object : List()

    ; #0
    push_back(object, "instruction value")
    ; #1
    push_back(object, targets)
    ; #2
    push_back(object, buffer)

    super(object)
}
; @type Value: Or(Immediate_Value, Instruction_Value)

; dummy super
terminator() {}

; restore buffer of internal instruction at the call time
; @param params: List(Value)
restore_buffer(internal, params) {
    ; original buffer
    buffer : get_buffer(internal)

    internal : Immediate_Value(internal)
    push_front(buffer, internal) ; add self at 0

    ; add params
    callback(param) {
        push_back(buffer, param)
    }

    map(params, callback)

    ; transform buffer according to template
    template : get_template(/internal)
    targets : get_targets(template)

    callback(index) {
        value : get(buffer, index)
        value : Immediate_Value(value)

        super(value)
    }

    next : map(targets, callback)

    super(next)
}

; @param instruction: Value
; @returns List(Value)
extract_targets(instruction) {
    type : get(instruction, 0)

    check_immediate() {
        is_not_immediate : !=(type, "immediate value")

        if (is_not_immediate, super)

        ; print("immmediate")

        value : get(instruction, 1)

        ; assumes that value is internal instruction
        targets : get_targets(value)
        targets : map(targets, Immediate_Value)

        /super(targets)
    }

    check_immediate()

    throw("cannot extract targets")
}

; @param buffer: List(Value)
step(buffer) {
    op : get(buffer, 0)

    ; print("op: ", op)

    type : get(op, 0)

    check_immediate() {
        is_not_immediate : !=(type, "immediate value")

        if (is_not_immediate, super)

        print("immediate")

        value : get(op, 1)

        ; print(value)

        check_bind() {
            is_not_bind : !=(value, bind)

            if (is_not_bind, super)

            print("bind")

            ; slice params for next & target
            params : slice(buffer, 3)

            ; create contonuation instruction
            next : get(buffer, 1)
            next : extract_targets(next)
            next : Instruction_Value(next, params)

            ; create target instruction
            target : get(buffer, 2)
            target : extract_targets(target)
            target : Instruction_Value(target, params)

            push_back(params, target)

            ; fill next buffer
            buffer : List()

            push_back(buffer, next) ; next as currect program
            push_back(buffer, next) ; next as super (is this even needed?)

            //super(buffer)
        }
        check_throw() {
            is_not_throw : !=(value, throw)

            if (is_not_throw, super)

            print("throw")

            throw("throw reached")
        }

        check_bind()
        check_throw()

        throw("cannot check over immediate")
    }
    check_instruction() {
        is_not_instruction : !=(type, "instruction value")

        if (is_not_instruction, super)

        print("instruction")

        targets : get(op, 1)
        buffer : get(op, 2)
        params : slice(buffer, 1)

        buffer : slice(buffer) ; copy buffer
        push_front(buffer, op)
        buffer : +(buffer, params)

        callback(target) {
            type : get(target, 0)

            check_immediate() {
                is_not_immediate : !=(type, "immediate value")

                if (is_not_immediate, super)

                ; print("immediate")

                value : get(op, 1)
                value : get(buffer, value)

                /super(value)
            }

            check_immediate()

            throw("cannot process target")
        }

        buffer : map(targets, callback)

        /super(buffer)
    }

    check_immediate()
    check_instruction()

    throw("cannot step")
}

params : List()

; add terminator as super
push_back(params, terminator)

params : map(params, Immediate_Value)
buffer : restore_buffer(f, params)

buffer : step(buffer)
buffer : step(buffer)
buffer : step(buffer)
